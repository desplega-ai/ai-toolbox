# Hive v0.2 - Claude Agent SDK Integration Implementation Plan

## Overview

Integrate the Claude Agent SDK (`@anthropic-ai/claude-agent-sdk`) into Hive to enable actual Claude Code sessions. This phase replaces the placeholder Agent tab with a working session interface that supports creating sessions, sending messages, streaming responses, permission handling, interrupts, and native notifications.

## Current State Analysis

- **Foundation complete**: Hive v0.1 has working project/session CRUD, SQLite storage, theming, and tab management
- **Placeholder UI**: SessionView has a disabled input field and "Claude SDK integration placeholder" message
- **Database ready**: `sessions` table has `claude_session_id` column for storing SDK session IDs
- **Research complete**: `2025-12-15-hive-claude-sdk-integration.md` documents all SDK patterns

### Key Discoveries:
- SDK uses V1 `query()` function returning AsyncGenerator (`hive-claude-sdk-integration.md:41-44`)
- Sessions tracked via `session_id` from init message (`hive-claude-sdk-integration.md:82-87`)
- Permission handling via `canUseTool` callback (`hive-claude-sdk-integration.md:429-456`)
- Interrupts via `query.interrupt()` method (`hive-claude-sdk-integration.md:464-494`)
- Partial streaming with `includePartialMessages: true` (`hive-claude-sdk-integration.md:261-291`)

## Desired End State

After completing this plan:

1. **Working Claude sessions** via `@anthropic-ai/claude-agent-sdk`
2. **Real-time streaming** with character-level output as Claude types
3. **Session persistence** - resume sessions across app restarts
4. **Permission UI** - approve/deny tool usage with optional "remember" choice
5. **Interrupt support** - stop running queries mid-execution
6. **Native notifications** when input is required or task completes
7. **Credential configuration** - support Claude CLI creds and API key input

### Verification:
- Create a new session, send "What files are in this directory?", see streaming response
- Close and reopen app, resume the session with a follow-up message
- Trigger a permission request (e.g., "Create a file called test.txt"), see approval dialog
- Click interrupt button while Claude is typing, see it stop
- Background the app, trigger "awaiting input", see native notification appear

## What We're NOT Doing

1. **OAuth tokens** - CLI-only, not for third-party SDK apps per Anthropic docs
2. **V2 SDK** - Using V1 for `interrupt()` and `forkSession` support
3. **Session forking UI** - Deferred (backend support only)
4. **Bedrock/Vertex/Azure config UI** - Just API key for now
5. **MCP server integration** - Deferred to later phase
6. **Custom tools** - Using preset `claude_code` tools only
7. **Diff tab** - Still placeholder
8. **Analytics tab** - Still placeholder
9. **Thoughts tab** - Still placeholder (Phase 8)

## Implementation Approach

Build in layers:
1. Install SDK and verify it works in main process
2. Create SessionManager class to wrap SDK operations
3. Add IPC channels for session operations
4. Build permission dialog component
5. Replace placeholder Agent tab with working UI
6. Add notification support

---

## Phase 1: SDK Installation & Verification

### Overview
Install the Claude Agent SDK and verify it initializes correctly in Electron's main process.

### Changes Required:

#### 1. Install SDK
**Location**: `hive/`

```bash
cd /Users/taras/Documents/code/ai-toolbox/hive
pnpm add @anthropic-ai/claude-agent-sdk
```

#### 2. Verify SDK Loads
**File**: `hive/src/main/index.ts`

Add a temporary test to verify SDK loads:

```typescript
// Temporary: verify SDK loads
import { query } from '@anthropic-ai/claude-agent-sdk';
console.log('Claude Agent SDK loaded:', typeof query === 'function');
```

#### 3. Update Vite Main Config (if needed)
**File**: `hive/vite.main.config.mjs`

Ensure SDK is externalized:

```javascript
import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@shared': path.resolve(__dirname, 'src/shared'),
      '@main': path.resolve(__dirname, 'src/main'),
    },
  },
  build: {
    rollupOptions: {
      external: [
        'electron',
        'better-sqlite3',
        'electron-store',
        'electron-window-state',
        '@anthropic-ai/claude-agent-sdk',
      ],
    },
  },
});
```

### Success Criteria:

#### Automated Verification:
- [x] SDK installs without errors: `cd hive && pnpm add @anthropic-ai/claude-agent-sdk`
- [x] TypeScript compiles: `cd hive && pnpm exec tsc --noEmit`
- [x] App starts: `cd hive && pnpm start`

#### Manual Verification:
- [x] Console shows "Claude Agent SDK loaded: true"
- [x] No errors in Electron main process console

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 2.

---

## Phase 2: Session Manager Implementation

### Overview
Create `SessionManager` class that wraps the Claude Agent SDK for managing sessions.

### Changes Required:

#### 1. SDK Message Types
**File**: `hive/src/shared/sdk-types.ts` (new file)

```typescript
// Re-export relevant types from SDK and define our own
export interface SDKInitMessage {
  type: 'system';
  subtype: 'init';
  session_id: string;
  model: string;
  tools: string[];
  apiKeySource: string;
}

export interface SDKAssistantMessage {
  type: 'assistant';
  uuid: string;
  session_id: string;
  message: {
    role: 'assistant';
    content: Array<{
      type: 'text' | 'tool_use';
      text?: string;
      id?: string;
      name?: string;
      input?: unknown;
    }>;
  };
}

export interface SDKResultMessage {
  type: 'result';
  subtype: 'success' | 'error_max_turns' | 'error_during_execution' | 'error_max_budget_usd';
  session_id: string;
  result?: string;
  total_cost_usd?: number;
  duration_ms?: number;
}

export interface SDKStreamEvent {
  type: 'stream_event';
  event: {
    type: 'content_block_start' | 'content_block_delta' | 'content_block_stop';
    content_block?: { type: string };
    delta?: { type: string; text?: string };
  };
  session_id: string;
  uuid: string;
}

export type SDKMessage = SDKInitMessage | SDKAssistantMessage | SDKResultMessage | SDKStreamEvent | { type: string; [key: string]: unknown };

// Permission request from renderer
export interface PermissionRequest {
  id: string;
  sessionId: string;
  toolName: string;
  input: unknown;
  timestamp: number;
}

export interface PermissionResponse {
  id: string;
  approved: boolean;
  updatedInput?: unknown;
  remember?: boolean;
  message?: string;
}

// Events sent to renderer
export interface SessionOutputEvent {
  sessionId: string;
  message: SDKMessage;
}

export interface SessionStatusEvent {
  sessionId: string;
  status: 'idle' | 'running' | 'awaiting_input' | 'error';
}
```

#### 2. Auth Manager
**File**: `hive/src/main/auth-manager.ts` (new file)

```typescript
import ElectronStore from 'electron-store';
import { app } from 'electron';
import path from 'path';

const HIVE_DIR = path.join(app.getPath('home'), '.hive');
const Store = (ElectronStore as unknown as { default: typeof ElectronStore }).default || ElectronStore;

type AuthMethod = 'claude-cli' | 'api-key';

interface AuthConfig {
  method: AuthMethod;
  apiKey?: string;
}

const authStore = new Store<{ auth: AuthConfig }>({
  name: 'auth',
  cwd: HIVE_DIR,
  defaults: {
    auth: { method: 'claude-cli' }
  }
});

export function getAuthEnvironment(): Record<string, string> {
  const config = authStore.get('auth');
  const env: Record<string, string> = {};

  // Copy relevant env vars
  if (process.env.PATH) env.PATH = process.env.PATH;
  if (process.env.HOME) env.HOME = process.env.HOME;
  if (process.env.USER) env.USER = process.env.USER;
  if (process.env.SHELL) env.SHELL = process.env.SHELL;

  switch (config.method) {
    case 'claude-cli':
      // SDK inherits from CLI automatically
      break;
    case 'api-key':
      if (config.apiKey) {
        env.ANTHROPIC_API_KEY = config.apiKey;
      }
      break;
  }

  return env;
}

export function getAuthConfig(): AuthConfig {
  return authStore.get('auth');
}

export function setAuthConfig(config: AuthConfig): void {
  authStore.set('auth', config);
}

export function hasApiKey(): boolean {
  const config = authStore.get('auth');
  return config.method === 'api-key' && !!config.apiKey;
}
```

#### 3. Session Manager
**File**: `hive/src/main/session-manager.ts` (new file)

```typescript
import { query, type Query } from '@anthropic-ai/claude-agent-sdk';
import { BrowserWindow, Notification } from 'electron';
import { getAuthEnvironment } from './auth-manager';
import { database } from './database';
import type { Session } from '../shared/types';
import type { SDKMessage, PermissionRequest, PermissionResponse } from '../shared/sdk-types';

interface ActiveSession {
  query: Query;
  abortController: AbortController;
  pendingPermissions: Map<string, {
    resolve: (response: PermissionResponse) => void;
    request: PermissionRequest;
  }>;
}

export class SessionManager {
  private activeSessions = new Map<string, ActiveSession>();
  private mainWindow: BrowserWindow;

  constructor(mainWindow: BrowserWindow) {
    this.mainWindow = mainWindow;
  }

  async startSession(
    hiveSessionId: string,
    prompt: string,
    cwd: string,
    existingClaudeSessionId?: string
  ): Promise<void> {
    // Update status to running
    database.sessions.updateStatus(hiveSessionId, 'running');
    this.sendStatusUpdate(hiveSessionId, 'running');

    const abortController = new AbortController();

    const response = query({
      prompt,
      options: {
        cwd,
        model: 'claude-sonnet-4-5-20250929',
        resume: existingClaudeSessionId,
        env: getAuthEnvironment(),
        abortController,
        includePartialMessages: true,
        systemPrompt: { type: 'preset', preset: 'claude_code' },
        tools: { type: 'preset', preset: 'claude_code' },
        canUseTool: async (toolName, input) => {
          return this.handlePermissionRequest(hiveSessionId, toolName, input);
        }
      }
    });

    const activeSession: ActiveSession = {
      query: response,
      abortController,
      pendingPermissions: new Map()
    };

    this.activeSessions.set(hiveSessionId, activeSession);

    try {
      for await (const message of response) {
        // Update claude_session_id on init
        if (message.type === 'system' && message.subtype === 'init') {
          database.sessions.updateClaudeSessionId(hiveSessionId, message.session_id);
        }

        // Forward message to renderer
        this.sendMessage(hiveSessionId, message as SDKMessage);

        // Handle result
        if (message.type === 'result') {
          const isSuccess = message.subtype === 'success';
          database.sessions.updateStatus(hiveSessionId, 'idle');
          this.sendStatusUpdate(hiveSessionId, 'idle');
          this.sendCompletionNotification(hiveSessionId, isSuccess);
        }
      }
    } catch (error) {
      console.error('Session error:', error);
      database.sessions.updateStatus(hiveSessionId, 'error');
      this.sendStatusUpdate(hiveSessionId, 'error');
    } finally {
      this.activeSessions.delete(hiveSessionId);
    }
  }

  async interruptSession(hiveSessionId: string): Promise<void> {
    const active = this.activeSessions.get(hiveSessionId);
    if (active) {
      try {
        await active.query.interrupt();
      } catch {
        // Fallback to abort
        active.abortController.abort();
      }
      database.sessions.updateStatus(hiveSessionId, 'idle');
      this.sendStatusUpdate(hiveSessionId, 'idle');
    }
  }

  resolvePermission(hiveSessionId: string, response: PermissionResponse): void {
    const active = this.activeSessions.get(hiveSessionId);
    if (active) {
      const pending = active.pendingPermissions.get(response.id);
      if (pending) {
        pending.resolve(response);
        active.pendingPermissions.delete(response.id);

        // Update status back to running if approved
        if (response.approved) {
          database.sessions.updateStatus(hiveSessionId, 'running');
          this.sendStatusUpdate(hiveSessionId, 'running');
        }
      }
    }
  }

  private async handlePermissionRequest(
    hiveSessionId: string,
    toolName: string,
    input: unknown
  ): Promise<{ behavior: 'allow' | 'deny'; updatedInput?: unknown; message?: string }> {
    const active = this.activeSessions.get(hiveSessionId);
    if (!active) {
      return { behavior: 'deny', message: 'Session not found' };
    }

    const requestId = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const request: PermissionRequest = {
      id: requestId,
      sessionId: hiveSessionId,
      toolName,
      input,
      timestamp: Date.now()
    };

    // Update status to awaiting input
    database.sessions.updateStatus(hiveSessionId, 'awaiting_input');
    this.sendStatusUpdate(hiveSessionId, 'awaiting_input');

    // Send notification if window not focused
    this.sendInputRequiredNotification(hiveSessionId, toolName);

    // Send permission request to renderer
    this.mainWindow.webContents.send('session:permission-request', request);

    // Wait for response
    return new Promise((resolve) => {
      active.pendingPermissions.set(requestId, {
        resolve: (response: PermissionResponse) => {
          if (response.approved) {
            resolve({
              behavior: 'allow',
              updatedInput: response.updatedInput || input
            });
          } else {
            resolve({
              behavior: 'deny',
              message: response.message || 'User denied permission'
            });
          }
        },
        request
      });
    });
  }

  private sendMessage(sessionId: string, message: SDKMessage): void {
    if (!this.mainWindow.isDestroyed()) {
      this.mainWindow.webContents.send('session:message', { sessionId, message });
    }
  }

  private sendStatusUpdate(sessionId: string, status: Session['status']): void {
    if (!this.mainWindow.isDestroyed()) {
      this.mainWindow.webContents.send('session:status', { sessionId, status });
    }
  }

  private sendInputRequiredNotification(sessionId: string, toolName: string): void {
    if (this.mainWindow.isFocused()) return;

    const notification = new Notification({
      title: 'Input Required',
      body: `Claude wants to use: ${toolName}`,
      timeoutType: 'never'
    });

    notification.on('click', () => {
      this.mainWindow.show();
      this.mainWindow.focus();
      this.mainWindow.webContents.send('session:focus', sessionId);
    });

    notification.show();
  }

  private sendCompletionNotification(sessionId: string, success: boolean): void {
    if (this.mainWindow.isFocused()) return;

    const notification = new Notification({
      title: success ? 'Task Complete' : 'Task Error',
      body: success ? 'Claude finished the task' : 'Task ended with an error'
    });

    notification.on('click', () => {
      this.mainWindow.show();
      this.mainWindow.focus();
      this.mainWindow.webContents.send('session:focus', sessionId);
    });

    notification.show();
  }
}
```

#### 4. Update Database for Claude Session ID Updates
**File**: `hive/src/main/database.ts`

Add method to update `claude_session_id`:

```typescript
// Add to statements object
updateClaudeSessionId: db.prepare(`
  UPDATE sessions SET claude_session_id = ?, updated_at = ? WHERE id = ?
`),

// Add to database.sessions object
updateClaudeSessionId(id: string, claudeSessionId: string): void {
  statements.updateClaudeSessionId.run(claudeSessionId, Date.now(), id);
},

// Add method to get session by ID
getById(id: string): Session | undefined {
  const row = statements.getSessionById.all(id)[0] as SessionRow | undefined;
  if (!row) return undefined;
  return {
    ...row,
    metadata: JSON.parse(row.metadata || '{}'),
  };
},
```

Also add the prepared statement:
```typescript
getSessionById: db.prepare(`
  SELECT id, project_id as projectId, claude_session_id as claudeSessionId,
         name, action_type as actionType, status, metadata,
         created_at as createdAt, updated_at as updatedAt
  FROM sessions WHERE id = ?
`),
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `cd hive && pnpm exec tsc --noEmit`
- [x] App starts without errors: `cd hive && pnpm start`

#### Manual Verification:
- [x] No errors in console related to SessionManager
- [x] Auth store created at `~/.hive/auth.json`

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 3.

---

## Phase 3: IPC Handlers for Session Operations

### Overview
Add IPC handlers to connect renderer to SessionManager.

### Changes Required:

#### 1. Update IPC Handlers
**File**: `hive/src/main/ipc-handlers.ts`

```typescript
import { ipcMain, dialog, BrowserWindow } from 'electron';
import { database } from './database';
import { getPreferences, setPreferences, addRecentDirectory, getTabsState, setTabsState } from './preferences';
import { SessionManager } from './session-manager';
import { getAuthConfig, setAuthConfig } from './auth-manager';
import type { PermissionResponse } from '../shared/sdk-types';

let sessionManager: SessionManager | null = null;

export function registerIpcHandlers(mainWindow: BrowserWindow): void {
  // Initialize session manager
  sessionManager = new SessionManager(mainWindow);

  // Projects
  ipcMain.handle('db:projects:list', () => {
    return database.projects.list();
  });

  ipcMain.handle('db:projects:create', (_, data) => {
    const project = database.projects.create(data);
    addRecentDirectory(data.directory);
    return project;
  });

  ipcMain.handle('db:projects:delete', (_, { id }) => {
    database.projects.delete(id);
  });

  // Sessions
  ipcMain.handle('db:sessions:list', (_, { projectId }) => {
    return database.sessions.listByProject(projectId);
  });

  ipcMain.handle('db:sessions:create', (_, data) => {
    return database.sessions.create(data);
  });

  ipcMain.handle('db:sessions:get', (_, { id }) => {
    return database.sessions.getById(id);
  });

  // Session operations (Claude SDK)
  ipcMain.handle('session:start', async (_, { hiveSessionId, prompt, cwd, claudeSessionId }) => {
    if (!sessionManager) throw new Error('SessionManager not initialized');
    await sessionManager.startSession(hiveSessionId, prompt, cwd, claudeSessionId);
  });

  ipcMain.handle('session:interrupt', async (_, { hiveSessionId }) => {
    if (!sessionManager) throw new Error('SessionManager not initialized');
    await sessionManager.interruptSession(hiveSessionId);
  });

  ipcMain.handle('session:permission-response', (_, response: PermissionResponse) => {
    if (!sessionManager) throw new Error('SessionManager not initialized');
    sessionManager.resolvePermission(response.id.split('-')[0], response);
  });

  // Preferences
  ipcMain.handle('preferences:get', () => {
    return getPreferences();
  });

  ipcMain.handle('preferences:set', (_, updates) => {
    setPreferences(updates);
    mainWindow.webContents.send('preferences:changed', getPreferences());
  });

  // Auth
  ipcMain.handle('auth:get', () => {
    return getAuthConfig();
  });

  ipcMain.handle('auth:set', (_, config) => {
    setAuthConfig(config);
  });

  // Dialogs
  ipcMain.handle('dialog:open-directory', async () => {
    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ['openDirectory', 'createDirectory'],
    });
    return result.canceled ? null : result.filePaths[0];
  });

  // Tabs state
  ipcMain.handle('tabs:get', () => {
    return getTabsState();
  });

  ipcMain.handle('tabs:set', (_, state) => {
    setTabsState(state);
  });
}
```

#### 2. Update Preload Script
**File**: `hive/src/preload/preload.ts`

```typescript
import { contextBridge, ipcRenderer } from 'electron';

export interface ElectronAPI {
  invoke: <T>(channel: string, ...args: unknown[]) => Promise<T>;
  on: (channel: string, callback: (...args: unknown[]) => void) => () => void;
  send: (channel: string, ...args: unknown[]) => void;
}

contextBridge.exposeInMainWorld('electronAPI', {
  invoke: <T>(channel: string, ...args: unknown[]): Promise<T> => {
    return ipcRenderer.invoke(channel, ...args);
  },
  on: (channel: string, callback: (...args: unknown[]) => void) => {
    const subscription = (_event: Electron.IpcRendererEvent, ...args: unknown[]) =>
      callback(...args);
    ipcRenderer.on(channel, subscription);
    return () => ipcRenderer.removeListener(channel, subscription);
  },
  send: (channel: string, ...args: unknown[]) => {
    ipcRenderer.send(channel, ...args);
  },
});
```

#### 3. Update Electron Type Declarations
**File**: `hive/src/renderer/electron.d.ts`

```typescript
export interface ElectronAPI {
  invoke: <T>(channel: string, ...args: unknown[]) => Promise<T>;
  on: (channel: string, callback: (...args: unknown[]) => void) => () => void;
  send: (channel: string, ...args: unknown[]) => void;
}

declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}

export {};
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `cd hive && pnpm exec tsc --noEmit`
- [x] App starts: `cd hive && pnpm start`

#### Manual Verification:
- [x] No IPC-related errors in console
- [x] DevTools shows IPC channels available

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 4.

---

## Phase 4: Permission Dialog Component

### Overview
Create a modal dialog for approving/denying tool usage.

### Changes Required:

#### 1. Permission Dialog Component
**File**: `hive/src/renderer/components/views/PermissionDialog.tsx` (new file)

```tsx
import React from 'react';
import { Shield, X, Check, AlertTriangle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import type { PermissionRequest } from '../../../shared/sdk-types';

interface PermissionDialogProps {
  request: PermissionRequest | null;
  onApprove: (request: PermissionRequest, remember: boolean) => void;
  onDeny: (request: PermissionRequest, message?: string) => void;
}

export function PermissionDialog({ request, onApprove, onDeny }: PermissionDialogProps) {
  const [remember, setRemember] = React.useState(false);

  if (!request) return null;

  const isDangerous = ['Bash', 'Write', 'Edit'].includes(request.toolName);
  const inputPreview = typeof request.input === 'object'
    ? JSON.stringify(request.input, null, 2).slice(0, 500)
    : String(request.input).slice(0, 500);

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div className="absolute inset-0 bg-black/50" />

      {/* Dialog */}
      <div className="relative w-full max-w-lg bg-[var(--background)] rounded-lg shadow-xl border border-[var(--border)]">
        {/* Header */}
        <div className={`flex items-center gap-3 p-4 border-b border-[var(--border)] ${
          isDangerous ? 'bg-[var(--warning)]/10' : 'bg-[var(--primary)]/10'
        }`}>
          {isDangerous ? (
            <AlertTriangle className="h-5 w-5 text-[var(--warning)]" />
          ) : (
            <Shield className="h-5 w-5 text-[var(--primary)]" />
          )}
          <div>
            <h2 className="font-semibold">Permission Required</h2>
            <p className="text-sm text-[var(--foreground-muted)]">
              Claude wants to use: <code className="bg-[var(--secondary)] px-1 rounded">{request.toolName}</code>
            </p>
          </div>
        </div>

        {/* Content */}
        <div className="p-4 space-y-4">
          {/* Input preview */}
          <div>
            <h3 className="text-sm font-medium mb-2">Details:</h3>
            <pre className="text-xs bg-[var(--secondary)] p-3 rounded overflow-auto max-h-48 font-mono">
              {inputPreview}
              {inputPreview.length >= 500 && '...'}
            </pre>
          </div>

          {/* Remember checkbox */}
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={remember}
              onChange={(e) => setRemember(e.target.checked)}
              className="rounded"
            />
            Remember this choice for this session
          </label>
        </div>

        {/* Actions */}
        <div className="flex justify-end gap-2 p-4 border-t border-[var(--border)]">
          <Button
            variant="outline"
            onClick={() => onDeny(request, 'User denied permission')}
          >
            <X className="h-4 w-4 mr-2" />
            Deny
          </Button>
          <Button
            onClick={() => onApprove(request, remember)}
          >
            <Check className="h-4 w-4 mr-2" />
            Approve
          </Button>
        </div>
      </div>
    </div>
  );
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `cd hive && pnpm exec tsc --noEmit`

#### Manual Verification:
- [x] Component renders correctly (will test in Phase 5)

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 5.

---

## Phase 5: Agent Tab Implementation

### Overview
Replace the placeholder Agent tab with a working chat interface.

### Changes Required:

#### 1. Message Components
**File**: `hive/src/renderer/components/session/MessageList.tsx` (new file)

```tsx
import React from 'react';
import { cn } from '@/lib/utils';
import type { SDKMessage, SDKAssistantMessage } from '../../../shared/sdk-types';

interface MessageListProps {
  messages: SDKMessage[];
  streamingText: string;
}

export function MessageList({ messages, streamingText }: MessageListProps) {
  const scrollRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages, streamingText]);

  return (
    <div ref={scrollRef} className="flex-1 overflow-auto p-4 space-y-4">
      {messages.map((msg, index) => (
        <MessageItem key={index} message={msg} />
      ))}
      {streamingText && (
        <div className="bg-[var(--secondary)] rounded-lg p-3">
          <div className="text-xs text-[var(--foreground-muted)] mb-1">Claude</div>
          <div className="whitespace-pre-wrap font-mono text-sm">{streamingText}</div>
          <span className="inline-block w-2 h-4 bg-[var(--primary)] animate-pulse ml-0.5" />
        </div>
      )}
    </div>
  );
}

function MessageItem({ message }: { message: SDKMessage }) {
  if (message.type === 'assistant') {
    const assistantMsg = message as SDKAssistantMessage;
    const textContent = assistantMsg.message.content
      .filter((block) => block.type === 'text')
      .map((block) => block.text)
      .join('');

    const toolUses = assistantMsg.message.content.filter((block) => block.type === 'tool_use');

    return (
      <div className="bg-[var(--secondary)] rounded-lg p-3">
        <div className="text-xs text-[var(--foreground-muted)] mb-1">Claude</div>
        {textContent && (
          <div className="whitespace-pre-wrap font-mono text-sm">{textContent}</div>
        )}
        {toolUses.map((tool, i) => (
          <div key={i} className="mt-2 text-xs bg-[var(--background)] rounded p-2 border border-[var(--border)]">
            <span className="text-[var(--primary)]">Tool:</span> {tool.name}
          </div>
        ))}
      </div>
    );
  }

  if (message.type === 'system' && (message as { subtype?: string }).subtype === 'init') {
    return (
      <div className="text-center text-xs text-[var(--foreground-muted)] py-2">
        Session started
      </div>
    );
  }

  if (message.type === 'result') {
    const resultMsg = message as { subtype: string; result?: string };
    return (
      <div className={cn(
        "text-center text-xs py-2 rounded",
        resultMsg.subtype === 'success'
          ? "bg-[var(--success)]/10 text-[var(--success)]"
          : "bg-[var(--destructive)]/10 text-[var(--destructive)]"
      )}>
        {resultMsg.subtype === 'success' ? 'Task completed' : `Error: ${resultMsg.subtype}`}
      </div>
    );
  }

  return null;
}
```

#### 2. Message Input Component
**File**: `hive/src/renderer/components/session/MessageInput.tsx` (new file)

```tsx
import React from 'react';
import { Send, Square } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface MessageInputProps {
  onSend: (message: string) => void;
  onInterrupt: () => void;
  isRunning: boolean;
  disabled?: boolean;
}

export function MessageInput({ onSend, onInterrupt, isRunning, disabled }: MessageInputProps) {
  const [input, setInput] = React.useState('');
  const textareaRef = React.useRef<HTMLTextAreaElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (input.trim() && !isRunning && !disabled) {
      onSend(input.trim());
      setInput('');
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  // Auto-resize textarea
  React.useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 200)}px`;
    }
  }, [input]);

  return (
    <form onSubmit={handleSubmit} className="p-4 border-t border-[var(--border)]">
      <div className="flex gap-2">
        <textarea
          ref={textareaRef}
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={isRunning ? "Claude is working..." : "Type a message..."}
          disabled={isRunning || disabled}
          rows={1}
          className="flex-1 px-3 py-2 rounded border border-[var(--border)] bg-[var(--background)] text-[var(--foreground)] placeholder:text-[var(--foreground-muted)] disabled:opacity-50 resize-none font-mono text-sm"
        />
        {isRunning ? (
          <Button type="button" variant="destructive" onClick={onInterrupt}>
            <Square className="h-4 w-4" />
          </Button>
        ) : (
          <Button type="submit" disabled={!input.trim() || disabled}>
            <Send className="h-4 w-4" />
          </Button>
        )}
      </div>
    </form>
  );
}
```

#### 3. Update SessionView
**File**: `hive/src/renderer/components/views/SessionView.tsx`

Replace the entire file:

```tsx
import React from 'react';
import { cn } from '@/lib/utils';
import { MessageList } from '@/components/session/MessageList';
import { MessageInput } from '@/components/session/MessageInput';
import { PermissionDialog } from './PermissionDialog';
import type { Session } from '../../../shared/types';
import type { SDKMessage, PermissionRequest, PermissionResponse, SDKStreamEvent } from '../../../shared/sdk-types';

interface SessionViewProps {
  session: Session;
  projectDirectory: string;
}

type TabId = 'agent' | 'diff' | 'analytics' | 'thoughts';

export function SessionView({ session, projectDirectory }: SessionViewProps) {
  const [activeTab, setActiveTab] = React.useState<TabId>('agent');
  const [messages, setMessages] = React.useState<SDKMessage[]>([]);
  const [streamingText, setStreamingText] = React.useState('');
  const [status, setStatus] = React.useState<Session['status']>(session.status);
  const [permissionRequest, setPermissionRequest] = React.useState<PermissionRequest | null>(null);

  const tabs: { id: TabId; label: string }[] = [
    { id: 'agent', label: 'Agent' },
    { id: 'diff', label: 'Diff' },
    { id: 'analytics', label: 'Analytics' },
    { id: 'thoughts', label: 'Thoughts' },
  ];

  // Subscribe to session events
  React.useEffect(() => {
    const unsubMessage = window.electronAPI.on('session:message', (data: unknown) => {
      const { sessionId, message } = data as { sessionId: string; message: SDKMessage };
      if (sessionId !== session.id) return;

      // Handle streaming
      if (message.type === 'stream_event') {
        const streamEvent = message as SDKStreamEvent;
        if (streamEvent.event.type === 'content_block_delta' && streamEvent.event.delta?.text) {
          setStreamingText((prev) => prev + streamEvent.event.delta!.text);
        } else if (streamEvent.event.type === 'content_block_stop') {
          // Block complete, will get full message next
        }
        return;
      }

      // Clear streaming text when we get full message
      if (message.type === 'assistant') {
        setStreamingText('');
      }

      setMessages((prev) => [...prev, message]);
    });

    const unsubStatus = window.electronAPI.on('session:status', (data: unknown) => {
      const { sessionId, status: newStatus } = data as { sessionId: string; status: Session['status'] };
      if (sessionId === session.id) {
        setStatus(newStatus);
      }
    });

    const unsubPermission = window.electronAPI.on('session:permission-request', (request: unknown) => {
      const req = request as PermissionRequest;
      if (req.sessionId === session.id) {
        setPermissionRequest(req);
      }
    });

    return () => {
      unsubMessage();
      unsubStatus();
      unsubPermission();
    };
  }, [session.id]);

  const handleSendMessage = async (prompt: string) => {
    // Add user message to UI
    const userMessage: SDKMessage = {
      type: 'user',
      session_id: session.claudeSessionId || '',
      message: { role: 'user', content: [{ type: 'text', text: prompt }] }
    } as SDKMessage;
    setMessages((prev) => [...prev, userMessage]);

    // Start session via IPC
    await window.electronAPI.invoke('session:start', {
      hiveSessionId: session.id,
      prompt,
      cwd: projectDirectory,
      claudeSessionId: session.claudeSessionId
    });
  };

  const handleInterrupt = async () => {
    await window.electronAPI.invoke('session:interrupt', {
      hiveSessionId: session.id
    });
  };

  const handlePermissionApprove = (request: PermissionRequest, remember: boolean) => {
    const response: PermissionResponse = {
      id: request.id,
      approved: true,
      remember
    };
    window.electronAPI.invoke('session:permission-response', response);
    setPermissionRequest(null);
  };

  const handlePermissionDeny = (request: PermissionRequest, message?: string) => {
    const response: PermissionResponse = {
      id: request.id,
      approved: false,
      message
    };
    window.electronAPI.invoke('session:permission-response', response);
    setPermissionRequest(null);
  };

  return (
    <div className="h-full flex flex-col">
      {/* Tab Bar */}
      <div className="flex items-center border-b border-[var(--border)] bg-[var(--background-secondary)]">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={cn(
              'px-4 py-2 text-sm font-medium border-b-2 transition-colors',
              activeTab === tab.id
                ? 'border-[var(--primary)] text-[var(--foreground)]'
                : 'border-transparent text-[var(--foreground-muted)] hover:text-[var(--foreground)]'
            )}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Session Header */}
      <div className="px-4 py-2 border-b border-[var(--border)]">
        <div className="flex items-center gap-2">
          <span className="font-medium">{session.name}</span>
          <span className="text-xs px-2 py-0.5 rounded bg-[var(--secondary)] text-[var(--secondary-foreground)]">
            {session.actionType}
          </span>
          <span className={cn(
            'text-xs px-2 py-0.5 rounded',
            status === 'running' && 'bg-[var(--success)]/20 text-[var(--success)]',
            status === 'awaiting_input' && 'bg-[var(--warning)]/20 text-[var(--warning)]',
            status === 'error' && 'bg-[var(--destructive)]/20 text-[var(--destructive)]',
            status === 'idle' && 'bg-[var(--secondary)] text-[var(--secondary-foreground)]'
          )}>
            {status}
          </span>
        </div>
      </div>

      {/* Tab Content */}
      <div className="flex-1 overflow-hidden flex flex-col">
        {activeTab === 'agent' && (
          <>
            <MessageList messages={messages} streamingText={streamingText} />
            <MessageInput
              onSend={handleSendMessage}
              onInterrupt={handleInterrupt}
              isRunning={status === 'running'}
            />
          </>
        )}
        {activeTab === 'diff' && <PlaceholderTab title="Diff" />}
        {activeTab === 'analytics' && <PlaceholderTab title="Analytics" />}
        {activeTab === 'thoughts' && <PlaceholderTab title="Thoughts" />}
      </div>

      {/* Permission Dialog */}
      <PermissionDialog
        request={permissionRequest}
        onApprove={handlePermissionApprove}
        onDeny={handlePermissionDeny}
      />
    </div>
  );
}

function PlaceholderTab({ title }: { title: string }) {
  return (
    <div className="h-full flex items-center justify-center">
      <p className="text-[var(--foreground-muted)]">
        {title} tab - Coming soon
      </p>
    </div>
  );
}
```

#### 4. Update ProjectView to Pass Directory
**File**: `hive/src/renderer/components/views/ProjectView.tsx`

Update the SessionView usage to pass `projectDirectory`:

```tsx
{currentSession ? (
  <SessionView session={currentSession} projectDirectory={currentProject.directory} />
) : (
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `cd hive && pnpm exec tsc --noEmit`
- [x] App starts: `cd hive && pnpm start`

#### Manual Verification:
- [x] Create new session in a project
- [x] Type message and send - see "Session started" indicator
- [x] See streaming text as Claude types
- [x] See complete message after Claude finishes
- [x] Click stop button to interrupt running session
- [x] See permission dialog when Claude wants to use a tool

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 6.

### Additional Improvements Made (Beyond Original Plan):

1. **Session status lifecycle updated**: Changed from `idle/running/awaiting_input/error` to `pending/running/waiting/idle/error/finished/archived`
2. **Messages now persist per session**: Added `useSessionMessagesStore` in zustand to store messages keyed by session ID
3. **Sidebar auto-updates**: Added global listener for session status changes
4. **Simplified sidebar grouping**: Changed from multiple groups to just "ACTIVE" and "DONE"
5. **Permission UI moved inline**: Permission requests now appear in chat instead of modal overlay
6. **Interrupt shows "Session interrupted"**: Better UX than showing "error_during_execution"
7. **Color-coded session status icons**: Each status has distinct color in sidebar

---

## Phase 6: Settings & Auth Configuration

### Overview
Add API key configuration to Settings modal.

### Changes Required:

#### 1. Update Settings Modal
**File**: `hive/src/renderer/components/views/SettingsModal.tsx`

```tsx
import React from 'react';
import { X, Eye, EyeOff, Check } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useThemeStore } from '@/lib/store';

interface AuthConfig {
  method: 'claude-cli' | 'api-key';
  apiKey?: string;
}

interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function SettingsModal({ isOpen, onClose }: SettingsModalProps) {
  const { theme, setTheme } = useThemeStore();
  const [authConfig, setAuthConfig] = React.useState<AuthConfig>({ method: 'claude-cli' });
  const [apiKeyInput, setApiKeyInput] = React.useState('');
  const [showApiKey, setShowApiKey] = React.useState(false);
  const [saved, setSaved] = React.useState(false);

  // Load auth config on open
  React.useEffect(() => {
    if (isOpen) {
      loadAuthConfig();
    }
  }, [isOpen]);

  const loadAuthConfig = async () => {
    const config = await window.electronAPI.invoke<AuthConfig>('auth:get');
    setAuthConfig(config);
    if (config.apiKey) {
      setApiKeyInput(config.apiKey);
    }
  };

  const handleSaveApiKey = async () => {
    const newConfig: AuthConfig = {
      method: 'api-key',
      apiKey: apiKeyInput
    };
    await window.electronAPI.invoke('auth:set', newConfig);
    setAuthConfig(newConfig);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
  };

  const handleUseCliAuth = async () => {
    const newConfig: AuthConfig = { method: 'claude-cli' };
    await window.electronAPI.invoke('auth:set', newConfig);
    setAuthConfig(newConfig);
    setApiKeyInput('');
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div className="absolute inset-0 bg-black/50" onClick={onClose} />

      {/* Modal */}
      <div className="relative w-full max-w-lg bg-[var(--background)] rounded-lg shadow-xl border border-[var(--border)]">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-[var(--border)]">
          <h2 className="text-lg font-semibold">Settings</h2>
          <Button variant="ghost" size="icon" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </div>

        {/* Content */}
        <div className="p-4 space-y-6">
          {/* Theme */}
          <div>
            <h3 className="text-sm font-medium mb-3">Theme</h3>
            <div className="flex gap-2">
              {(['light', 'dark', 'system'] as const).map((t) => (
                <button
                  key={t}
                  onClick={() => setTheme(t)}
                  className={`px-4 py-2 rounded border transition-colors ${
                    theme === t
                      ? 'border-[var(--primary)] bg-[var(--primary)]/10'
                      : 'border-[var(--border)] hover:border-[var(--foreground-muted)]'
                  }`}
                >
                  {t.charAt(0).toUpperCase() + t.slice(1)}
                </button>
              ))}
            </div>
          </div>

          {/* Authentication */}
          <div>
            <h3 className="text-sm font-medium mb-3">Authentication</h3>

            <div className="space-y-3">
              {/* Claude CLI option */}
              <label className={`flex items-start gap-3 p-3 rounded border cursor-pointer ${
                authConfig.method === 'claude-cli'
                  ? 'border-[var(--primary)] bg-[var(--primary)]/10'
                  : 'border-[var(--border)]'
              }`}>
                <input
                  type="radio"
                  name="auth"
                  checked={authConfig.method === 'claude-cli'}
                  onChange={handleUseCliAuth}
                  className="mt-1"
                />
                <div>
                  <div className="font-medium">Use Claude CLI credentials</div>
                  <div className="text-sm text-[var(--foreground-muted)]">
                    Inherits authentication from the <code>claude</code> CLI tool
                  </div>
                </div>
              </label>

              {/* API Key option */}
              <label className={`flex items-start gap-3 p-3 rounded border cursor-pointer ${
                authConfig.method === 'api-key'
                  ? 'border-[var(--primary)] bg-[var(--primary)]/10'
                  : 'border-[var(--border)]'
              }`}>
                <input
                  type="radio"
                  name="auth"
                  checked={authConfig.method === 'api-key'}
                  onChange={() => setAuthConfig({ ...authConfig, method: 'api-key' })}
                  className="mt-1"
                />
                <div className="flex-1">
                  <div className="font-medium">Use API Key</div>
                  <div className="text-sm text-[var(--foreground-muted)] mb-2">
                    Use an Anthropic API key directly
                  </div>

                  {authConfig.method === 'api-key' && (
                    <div className="flex gap-2">
                      <div className="relative flex-1">
                        <input
                          type={showApiKey ? 'text' : 'password'}
                          value={apiKeyInput}
                          onChange={(e) => setApiKeyInput(e.target.value)}
                          placeholder="sk-ant-..."
                          className="w-full px-3 py-2 pr-10 rounded border border-[var(--border)] bg-[var(--background)] text-sm font-mono"
                        />
                        <button
                          type="button"
                          onClick={() => setShowApiKey(!showApiKey)}
                          className="absolute right-2 top-1/2 -translate-y-1/2 text-[var(--foreground-muted)]"
                        >
                          {showApiKey ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </button>
                      </div>
                      <Button size="sm" onClick={handleSaveApiKey} disabled={!apiKeyInput}>
                        {saved ? <Check className="h-4 w-4" /> : 'Save'}
                      </Button>
                    </div>
                  )}
                </div>
              </label>
            </div>
          </div>

          {/* Storage */}
          <div>
            <h3 className="text-sm font-medium mb-3">Storage</h3>
            <p className="text-sm text-[var(--foreground-muted)]">
              Data stored at: <code>~/.hive/</code>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `cd hive && pnpm exec tsc --noEmit`
- [x] App starts: `cd hive && pnpm start`

#### Manual Verification:
- [x] Settings modal shows authentication options
- [x] Can switch between CLI and API key auth
- [x] API key can be entered and saved
- [x] API key persists after app restart
- [x] Eye button toggles API key visibility

**Implementation Note**: This is the final phase for v0.2. After completing all verification, the Claude SDK integration is functional.

---

## Testing Strategy

### Unit Tests (Deferred)
Unit testing for SessionManager and IPC handlers will be added in a future phase.

### Integration Tests (Deferred)
End-to-end tests with mock SDK will be added later.

### Manual Testing Steps

1. **Fresh Session Test**:
   - Create new project pointing to a codebase
   - Create new session
   - Send "What files are in this directory?"
   - Verify streaming response appears
   - Verify "Task completed" indicator

2. **Resume Session Test**:
   - Close and reopen app
   - Open previous project/session
   - Send follow-up message
   - Verify session context maintained

3. **Permission Test**:
   - Send "Create a file called test.txt with 'Hello World'"
   - Verify permission dialog appears
   - Click Approve
   - Verify file is created

4. **Interrupt Test**:
   - Send a long-running request
   - Click stop button mid-stream
   - Verify session returns to idle

5. **Notification Test**:
   - Background the app
   - Send a request that requires permission
   - Verify macOS notification appears
   - Click notification to return to app

6. **API Key Test**:
   - Open Settings
   - Enter valid API key
   - Create new session
   - Verify session works with API key auth

---

## Performance Considerations

- Streaming uses `includePartialMessages` for real-time UI updates
- Messages stored in component state (not persisted to DB yet)
- AbortController provides quick cancellation
- SQLite updates are synchronous but fast (prepared statements)

---

## Implemented: Interrupt-and-Resume Permission Flow âœ…

### Problem (Solved)
The Claude Agent SDK has an internal ~5 second timeout for `canUseTool` callbacks. This made interactive permission prompts impractical.

### Solution Implemented

Used a **hash-based pre-approval with deny-and-resume** pattern:

#### Flow:
1. **When `canUseTool` is called:**
   - Compute deterministic hash of `{ tool, input }` (with recursive key sorting for order-independence)
   - Check if hash is pre-approved in `approved_tool_calls` table
   - If pre-approved: Allow tool, delete one-time approval
   - If not: Store in `pending_approvals` table, send permission request to UI, return deny

2. **Show permission UI:**
   - Permission card shown **inline** with the tool_use block in chat
   - No time pressure - user can take unlimited time
   - Supports multiple pending approvals with "Approve All" button
   - Persisted in SQLite - survives app restart

3. **When user responds:**
   - **Approve**: Store hash in `approved_tool_calls`, resume session with "Please continue"
   - **Deny**: Resume session with denial message explaining Claude should try different approach

4. **On resume:**
   - Claude retries the exact same tool call (from session history)
   - `canUseTool` finds pre-approved hash
   - Tool executes successfully

#### Key Implementation Details:

**Database tables added:**
- `pending_approvals`: `id, session_id, tool_use_id, tool_name, tool_input, hash, created_at`
- `approved_tool_calls`: `id, session_id, hash, approved_at`

**Hash function** (`src/shared/tool-hash.ts`):
- SHA-256 hash of `{ tool, input }` with recursive key sorting
- First 16 chars of hex digest for compact storage

**Deny message:**
```typescript
'[SYSTEM] PERMISSION_DENIED: User approval required for this tool. The operation was NOT executed. You MUST stop immediately and wait. Do NOT claim the task was completed. Do NOT try alternative approaches. Do NOT respond with any text. STOP NOW.'
```
This forceful message prevents Claude from falsely claiming success.

**UI enhancements:**
- Permission requests shown inline at the tool_use location
- Tool-specific detail views (Write, Edit, Bash, Read, Glob, Grep)
- Dangerous tools (Bash, Write, Edit) highlighted in warning color
- Token usage stats on assistant messages
- Result summary with duration, cost, tokens

#### Advantages over original proposal:
- âœ… No race conditions - deny is synchronous
- âœ… Hash matching ensures exact tool retry
- âœ… Persists across app restart
- âœ… Supports multiple simultaneous approvals
- âœ… No additional token cost for approval messages (only on deny resume)

---

## Implemented: UI Polish & Session Management Improvements âœ…

### Problem (Solved)
Several UI/UX issues needed addressing:
1. Send/Interrupt button not switching when session starts
2. No visual indicator for running sessions in sidebar
3. Session name not editable
4. Tooltips using native `title` attribute weren't visible
5. Session list not updating in real-time globally
6. Tabs in session details view had minimal differentiation
7. No way to mark sessions as complete or archive them

### Solutions Implemented

#### 1. Send/Interrupt Button & Spinner
- Added local status tracking (`localStatus` state) in SessionView that updates immediately on send
- Status now syncs via IPC events for backend updates
- Shows interrupt button immediately when running
- Spinner next to session name in header

#### 2. Sidebar Running Indicator
- Added `SessionStatusIcon` component with spinning `Loader2` for running sessions
- Each status has distinct icon: running (spinner), waiting (alert), error (X), finished (check), archived (archive)
- Session list auto-updates globally via listeners in MainLayout

#### 3. Editable Session Name
- Click on session name to edit inline
- Added IPC handler `db:sessions:update-name`
- Added database method `sessions.updateName()`

#### 4. Proper Tooltip Component
- Installed `@radix-ui/react-tooltip`
- Created `src/renderer/components/ui/tooltip.tsx`
- Wrapped app with `TooltipProvider`
- Updated usage stats to use proper Tooltip components
- Added CSS variables for popover styling

#### 5. Real-time Sidebar Updates
- Added global `session:status` and `session:permission-request` listeners in MainLayout
- Updates all tab states when any session status changes
- Tracks pending approval counts per session
- Shows approval count badge in sidebar

#### 6. Improved Tab Differentiation
- Tabs now have rounded-top style with background color for active
- Active tab appears "connected" to content area
- Clear visual separation between tabs

#### 7. Session Completion/Archiving
- Added "Mark Complete" button (sets status to `finished`)
- Added "Archive" button (sets status to `archived`)
- Buttons shown only when session is not running
- Sessions automatically sorted: Active (waiting > running > error > pending > idle) then Done (finished > archived)

#### Files Modified:
- `src/renderer/components/views/SessionView.tsx` - local status, editable name, action buttons
- `src/renderer/components/layout/Sidebar.tsx` - status icons, grouping, approval badges
- `src/renderer/components/layout/MainLayout.tsx` - global listeners, approval counts
- `src/renderer/components/session/MessageList.tsx` - proper tooltips
- `src/renderer/components/ui/tooltip.tsx` - new component
- `src/renderer/App.tsx` - TooltipProvider wrapper
- `src/renderer/index.css` - popover CSS variables
- `src/main/ipc-handlers.ts` - session name update handler
- `src/main/database.ts` - updateName method

---

## Implemented: Settings & Shell Integration âœ…

### Problem (Solved)
Users needed configurable editor and terminal preferences, plus the ability to continue sessions in their terminal.

### Solutions Implemented

#### 1. Editor Selector in Settings
- Added `editorCommand` to Preferences type
- Preset buttons: VS Code, Cursor, Sublime Text, Vim, Neovim, Emacs, Custom
- Custom input field for non-standard editors
- Saves to `~/.hive/preferences.json`

#### 2. Terminal Selector in Settings
- Added `terminalCommand` to Preferences type
- macOS presets: Terminal, iTerm2, Alacritty, Kitty, Warp, Custom
- Linux presets: GNOME Terminal, Konsole, Alacritty, Kitty, xterm, Custom
- Auto-detects platform for showing appropriate presets

#### 3. Open in Editor (`shell:open-in-editor`)
- IPC handler spawns editor directly with path
- Uses configured `editorCommand` from preferences
- Falls back to system file manager on error

#### 4. Continue in Terminal (`shell:open-in-terminal`)
- New IPC handler for opening terminal with command
- Platform-specific terminal launching:
  - macOS Terminal.app, iTerm: AppleScript `do script`
  - macOS Warp: Opens directory + copies command to clipboard (Warp doesn't support AppleScript commands)
  - macOS Alacritty/Kitty: Direct spawn with `-e` flag
  - Linux: Supports gnome-terminal, konsole, and generic terminals
- Full command: `cd '<project>' && claude --resume <session_id>`

#### 5. Session Action Buttons
- **Copy Command**: Copies `claude --resume <session_id>` to clipboard with "Copied!" feedback
- **Continue in Terminal**: Opens configured terminal, cds to project, runs resume command
- Both buttons only shown when session has a `claudeSessionId`

#### Files Modified:
- `src/shared/types.ts` - Added `editorCommand`, `terminalCommand` to Preferences
- `src/main/preferences.ts` - Added defaults and getters for new preferences
- `src/main/ipc-handlers.ts` - Added `shell:open-in-terminal`, updated `shell:open-in-editor`
- `src/renderer/components/views/SettingsModal.tsx` - Editor & terminal selector UI
- `src/renderer/components/views/SessionView.tsx` - Copy Command & Continue in Terminal buttons

---

## Implemented: UI Polish & Keyboard Shortcuts Phase 2 âœ…

### Problems (Solved)
Several additional UI/UX improvements were needed:
1. No visual indicator when Claude is thinking/reasoning before streaming
2. Local command output (e.g., `/cost`, `/context`) displayed as raw text with XML tags
3. No markdown rendering for assistant messages
4. Slash commands showed ugly `<command-name>` tags
5. Session action buttons took too much space
6. "Open in Editor" button didn't show which editor
7. Session count on start page was always 0
8. Messages lost when switching tabs
9. Input text lost when switching sessions/tabs
10. Activity indicator showed across all sessions
11. No keyboard shortcuts for tab management
12. Input field was small (1 line) and couldn't be edited externally

### Solutions Implemented

#### 1. Activity Indicators
- Added `Activity` type: `'idle' | 'connecting' | 'thinking' | 'streaming' | 'tool_use'`
- `ActivityIndicator` component shows stage with icons and animated bouncing dots
- Stages: Connecting â†’ Thinking â†’ Responding â†’ Using tools â†’ idle
- Resets to 'idle' when switching sessions

**Files**: `SessionView.tsx`, `MessageList.tsx`

#### 2. Local Command Output Handling
- Created `UserMessageContent` component to parse and render:
  - `<local-command-stdout>` tags as styled output blocks
  - `<command-name>` tags as slash command badges
  - Regular user messages
- Output displayed in bordered container with "Command Output" header

**File**: `MessageList.tsx`

#### 3. Markdown Rendering
- Installed `react-markdown` and `remark-gfm`
- Created `Markdown` component with custom styled elements
- Supports: headers, tables, code blocks, lists, links, blockquotes
- Used for local command output and assistant messages

**Files**: `src/renderer/components/ui/markdown.tsx`, `MessageList.tsx`

#### 4. Assistant Message Raw/Formatted Toggle
- Added toggle button (Code/Eye icons) on assistant messages
- Formatted view uses Markdown component
- Raw view shows original text in monospace

**File**: `MessageList.tsx`

#### 5. Icon-Only Session Action Buttons
- Changed Complete, Archive, Copy, Terminal buttons to icons
- Added Tooltip wrappers for each button
- Reduced header clutter while maintaining functionality

**File**: `SessionView.tsx`

#### 6. Editor Button Shows Actual Editor
- Added `EDITOR_NAMES` map for common editors
- `getEditorDisplayName()` function extracts editor name from command
- Button shows "Open in VS Code", "Open in Neovim", etc.
- Styled as proper Button component

**File**: `ProjectView.tsx`

#### 7. Session Count Fix
- `StartView` now loads actual session counts per project
- Uses `Promise.all` to fetch counts in parallel
- Displays correct "X sessions" text

**File**: `StartView.tsx`

#### 8. Global Message Listener (Tab Switching Fix)
- Moved message IPC listener from `SessionView` to `App.tsx`
- `useGlobalSessionMessageListener` hook persists across tab switches
- Messages stored in `useSessionMessagesStore` by session ID
- Streaming text also handled globally

**File**: `App.tsx`

#### 9. Draft Persistence
- Added `useDraftsStore` with Zustand persist middleware
- Drafts associated with project + session
- Auto-saves with 500ms debounce
- Clears on send
- Survives tab/session switches and app restarts

**Files**: `src/renderer/lib/store.ts`, `MessageInput.tsx`

#### 10. Keyboard Shortcuts
Added to `MainLayout.tsx`:
| Shortcut | Action |
|----------|--------|
| `âŒ˜1-9` | Switch to tab by number |
| `âŒ˜W` | Close current tab (if >1 tab) |
| `âŒ˜T` | Create new tab |
| `âŒ˜N` | Create new session (dispatches event) |
| `âŒ˜O` | Open project selector (dispatches event) |

**Files**: `MainLayout.tsx`, `ProjectView.tsx` (listener), `StartView.tsx` (listener)

#### 11. Message Input Improvements
- **Height**: Starts at 2 lines, max 10 lines (21px line height)
- **Focus on new session**: `focus-message-input` event dispatched after session creation
- **Open in Editor (Ctrl+G)**:
  - Creates temp `.md` file in `/tmp/hive-prompt-<sessionId>-<timestamp>.md`
  - Opens in configured editor
  - Bi-directional sync: input â†” file
  - Uses `fs.watchFile` polling (300ms) for reliable change detection
  - Button highlighted when file is open
  - Auto-cleanup on send or session close

**Files**: `MessageInput.tsx`, `ipc-handlers.ts`

#### IPC Handlers Added:
- `prompt-file:open` - Create temp file, open in editor, start watching
- `prompt-file:update` - Sync content from input to file
- `prompt-file:focus` - Re-open file in editor
- `prompt-file:close` - Stop watching, delete temp file

---

## Implemented: Model Selection âœ…

### Problem (Solved)
Sessions were hardcoded to use `claude-sonnet-4-5-20250929`. Users needed:
1. Ability to select which model to use per session (Opus, Sonnet, Haiku)
2. Default to most capable model (Opus) for new sessions
3. Model choice persisted in database

### Solution Implemented

#### 1. Model Types
Added to `src/shared/types.ts`:
- `ClaudeModel` type: `'claude-opus-4-5-20250514' | 'claude-sonnet-4-5-20250514' | 'claude-haiku-4-5-20250514'`
- `CLAUDE_MODELS` array with value/label pairs for UI
- `DEFAULT_MODEL` constant: `'claude-opus-4-5-20250514'`
- Added `model` field to `Session` interface

#### 2. Database Support
- Migration: `ALTER TABLE sessions ADD COLUMN model TEXT DEFAULT 'claude-opus-4-5-20250514'`
- Updated prepared statements to include model
- Added `updateSessionModel()` method
- Fallback to `DEFAULT_MODEL` for existing sessions without model

#### 3. Session Manager
- `startSession()` accepts optional `model` parameter
- Uses `session.model` in SDK query options
- All resume methods (approve, approveAll, deny) pass session model

#### 4. UI
- Dropdown selector in session header (between action type and status badges)
- Disabled while session is running
- Immediate save on change
- Model passed when starting/resuming sessions

#### Files Modified:
- `src/shared/types.ts` - Model types and constants
- `src/main/database.ts` - Migration, statements, methods
- `src/main/session-manager.ts` - Model parameter in startSession
- `src/main/ipc-handlers.ts` - Model in session:start, db:sessions:update-model handler
- `src/renderer/lib/store.ts` - updateSessionModel action
- `src/renderer/components/layout/MainLayout.tsx` - updateSessionModel in TabContext
- `src/renderer/components/views/SessionView.tsx` - Model selector UI
- `src/renderer/components/views/ProjectView.tsx` - Default model on session creation

---

## References

### Related Research:
- `thoughts/shared/research/2025-12-15-hive-electron-app-research.md`
- `thoughts/shared/research/2025-12-15-hive-claude-sdk-integration.md`

### Previous Plan:
- `thoughts/shared/plans/2025-12-15-hive-v0.1-foundation-setup.md`

### External Resources:
- [Claude Agent SDK TypeScript](https://platform.claude.com/docs/en/agent-sdk/typescript)
- [@anthropic-ai/claude-agent-sdk npm](https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk)
